# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä»•æ§˜æ›¸

## ğŸ“‹ ç›®æ¬¡
1. [æ¦‚è¦](#æ¦‚è¦)
2. [èªè¨¼ãƒ»èªå¯](#èªè¨¼èªå¯)
3. [ãƒ‡ãƒ¼ã‚¿ä¿è­·](#ãƒ‡ãƒ¼ã‚¿ä¿è­·)
4. [é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
5. [å…¥åŠ›æ¤œè¨¼](#å…¥åŠ›æ¤œè¨¼)
6. [ç›£æŸ»ãƒ»ãƒ­ã‚°](#ç›£æŸ»ãƒ­ã‚°)
7. [ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ](#ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ)
8. [ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹](#ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹)

---

## ğŸ¯ æ¦‚è¦

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ–¹é‡
åŒ»å­¦éƒ¨ç ”ä¿®åŒ»æ¡ç”¨è©¦é¨“å¯¾ç­–ã‚¢ãƒ—ãƒªã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆã¯ã€ä»¥ä¸‹ã®åŸå‰‡ã«åŸºã¥ã„ã¦ã„ã¾ã™ï¼š

- **æ©Ÿå¯†æ€§**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®é©åˆ‡ãªä¿è­·
- **å®Œå…¨æ€§**: ãƒ‡ãƒ¼ã‚¿ã®æ­£ç¢ºæ€§ã¨ä¸€è²«æ€§ã®ç¶­æŒ
- **å¯ç”¨æ€§**: ã‚µãƒ¼ãƒ“ã‚¹ã®ç¶™ç¶šçš„ãªæä¾›
- **è²¬ä»»è¿½è·¡**: ã™ã¹ã¦ã®æ“ä½œã®ç›£æŸ»å¯èƒ½æ€§

### è„…å¨ãƒ¢ãƒ‡ãƒ«
- **èªè¨¼ãƒã‚¤ãƒ‘ã‚¹**: ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹é˜²æ­¢
- **ãƒ‡ãƒ¼ã‚¿æ¼æ´©**: å€‹äººæƒ…å ±ä¿è­·
- **SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ”»æ’ƒé˜²æ­¢
- **XSSæ”»æ’ƒ**: ã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒ†ã‚£ãƒ³ã‚°é˜²æ­¢
- **CSRFæ”»æ’ƒ**: ã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ã‚¸ã‚§ãƒªé˜²æ­¢

---

## ğŸ” èªè¨¼ãƒ»èªå¯

### èªè¨¼æ–¹å¼

#### 1. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼
```python
class PasswordManager:
    """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    @staticmethod
    def hash_password(password: str) -> str:
        """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–"""
        # PBKDF2 with SHA256, 100,000 iterations
        salt = secrets.token_hex(32)
        pwdhash = hashlib.pbkdf2_hmac(
            'sha256', 
            password.encode('utf-8'), 
            salt.encode('utf-8'), 
            100000
        )
        return salt + pwdhash.hex()
    
    @staticmethod
    def verify_password(stored_password: str, provided_password: str) -> bool:
        """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼"""
        salt = stored_password[:64]
        stored_hash = stored_password[64:]
        
        pwdhash = hashlib.pbkdf2_hmac(
            'sha256',
            provided_password.encode('utf-8'),
            salt.encode('utf-8'),
            100000
        )
        
        return pwdhash.hex() == stored_hash
    
    @staticmethod
    def validate_password_strength(password: str) -> Tuple[bool, List[str]]:
        """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ã‚’æ¤œè¨¼"""
        errors = []
        
        if len(password) < 8:
            errors.append("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
        
        if not re.search(r"[a-z]", password):
            errors.append("å°æ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
        
        if not re.search(r"[A-Z]", password):
            errors.append("å¤§æ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
        
        if not re.search(r"\d", password):
            errors.append("æ•°å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
        
        if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
            errors.append("ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
        
        return len(errors) == 0, errors
```

#### 2. ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†
```python
class SessionManager:
    """ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.session_timeout = timedelta(hours=24)
        self.max_failed_attempts = 5
        self.lockout_duration = timedelta(minutes=30)
    
    def create_session(self, user_id: str) -> str:
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä½œæˆ"""
        session_id = secrets.token_urlsafe(32)
        session_data = {
            'user_id': user_id,
            'created_at': datetime.now().isoformat(),
            'expires_at': (datetime.now() + self.session_timeout).isoformat(),
            'ip_address': self._get_client_ip(),
            'user_agent': self._get_user_agent()
        }
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«ä¿å­˜
        self._store_session(session_id, session_data)
        return session_id
    
    def validate_session(self, session_id: str) -> Optional[str]:
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’æ¤œè¨¼"""
        session_data = self._get_session(session_id)
        if not session_data:
            return None
        
        # æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯
        expires_at = datetime.fromisoformat(session_data['expires_at'])
        if datetime.now() > expires_at:
            self._remove_session(session_id)
            return None
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³æ›´æ–°
        self._extend_session(session_id)
        return session_data['user_id']
    
    def _get_client_ip(self) -> str:
        """ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆIPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—"""
        # ãƒ—ãƒ­ã‚­ã‚·ç’°å¢ƒã§ã®é©åˆ‡ãªIPå–å¾—
        return request.headers.get('X-Forwarded-For', request.remote_addr)
```

#### 3. ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
```python
class AccountLockoutManager:
    """ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆç®¡ç†"""
    
    def __init__(self):
        self.max_attempts = 5
        self.lockout_duration = timedelta(minutes=30)
    
    def record_failed_login(self, email: str) -> bool:
        """ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—ã‚’è¨˜éŒ²"""
        current_time = datetime.now()
        
        # å¤±æ•—å›æ•°ã‚’å–å¾—
        failed_attempts = self._get_failed_attempts(email)
        
        if failed_attempts >= self.max_attempts:
            # ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒ­ãƒƒã‚¯
            lockout_until = current_time + self.lockout_duration
            self._set_account_lockout(email, lockout_until)
            return False
        
        # å¤±æ•—å›æ•°ã‚’å¢—åŠ 
        self._increment_failed_attempts(email)
        return True
    
    def is_account_locked(self, email: str) -> bool:
        """ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        lockout_until = self._get_lockout_until(email)
        if not lockout_until:
            return False
        
        if datetime.now() < lockout_until:
            return True
        
        # ãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆæœŸé–“çµ‚äº†
        self._clear_lockout(email)
        return False
    
    def record_successful_login(self, email: str):
        """æˆåŠŸãƒ­ã‚°ã‚¤ãƒ³ã‚’è¨˜éŒ²"""
        self._clear_failed_attempts(email)
        self._clear_lockout(email)
```

### èªå¯åˆ¶å¾¡

#### 1. Row Level Security (RLS)
```sql
-- RLSãƒãƒªã‚·ãƒ¼ã®å®Ÿè£…
CREATE POLICY user_own_sessions ON practice_sessions
    FOR ALL USING (user_id = auth.uid()::uuid);

CREATE POLICY user_own_inputs ON practice_inputs
    FOR ALL USING (
        session_id IN (
            SELECT session_id FROM practice_sessions 
            WHERE user_id = auth.uid()::uuid
        )
    );

CREATE POLICY user_own_scores ON practice_scores
    FOR ALL USING (
        session_id IN (
            SELECT session_id FROM practice_sessions 
            WHERE user_id = auth.uid()::uuid
        )
    );
```

#### 2. æ¨©é™ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
```python
class AuthorizationManager:
    """èªå¯ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.role_permissions = {
            'user': ['read_own_data', 'write_own_data'],
            'admin': ['read_all_data', 'write_all_data', 'manage_users'],
            'moderator': ['read_all_data', 'moderate_content']
        }
    
    def check_permission(self, user_id: str, permission: str) -> bool:
        """æ¨©é™ã‚’ãƒã‚§ãƒƒã‚¯"""
        user_role = self._get_user_role(user_id)
        if not user_role:
            return False
        
        return permission in self.role_permissions.get(user_role, [])
    
    def require_permission(self, permission: str):
        """æ¨©é™è¦æ±‚ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                user_id = get_current_user_id()
                if not self.check_permission(user_id, permission):
                    raise PermissionError(f"æ¨©é™ãŒä¸è¶³ã—ã¦ã„ã¾ã™: {permission}")
                return func(*args, **kwargs)
            return wrapper
        return decorator
```

---

## ğŸ›¡ï¸ ãƒ‡ãƒ¼ã‚¿ä¿è­·

### ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–

#### 1. ä¿å­˜æ™‚æš—å·åŒ–
```python
class DataEncryption:
    """ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, encryption_key: str):
        self.key = hashlib.sha256(encryption_key.encode()).digest()
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã‚’æš—å·åŒ–"""
        # AES-256-GCMæš—å·åŒ–
        cipher = AES.new(self.key, AES.MODE_GCM)
        ciphertext, tag = cipher.encrypt_and_digest(data.encode())
        
        # æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
        encrypted_data = base64.b64encode(
            cipher.nonce + tag + ciphertext
        ).decode()
        
        return encrypted_data
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å·åŒ–"""
        # Base64ãƒ‡ã‚³ãƒ¼ãƒ‰
        encrypted_bytes = base64.b64decode(encrypted_data.encode())
        
        # ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†å‰²
        nonce = encrypted_bytes[:12]
        tag = encrypted_bytes[12:28]
        ciphertext = encrypted_bytes[28:]
        
        # å¾©å·åŒ–
        cipher = AES.new(self.key, AES.MODE_GCM, nonce=nonce)
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        
        return plaintext.decode()
```

#### 2. ãƒ‡ãƒ¼ã‚¿ãƒã‚¹ã‚­ãƒ³ã‚°
```python
class DataMasking:
    """ãƒ‡ãƒ¼ã‚¿ãƒã‚¹ã‚­ãƒ³ã‚°ã‚¯ãƒ©ã‚¹"""
    
    @staticmethod
    def mask_email(email: str) -> str:
        """ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ãƒã‚¹ã‚¯"""
        if '@' not in email:
            return email
        
        username, domain = email.split('@')
        if len(username) <= 2:
            masked_username = username
        else:
            masked_username = username[0] + '*' * (len(username) - 2) + username[-1]
        
        return f"{masked_username}@{domain}"
    
    @staticmethod
    def mask_name(name: str) -> str:
        """åå‰ã‚’ãƒã‚¹ã‚¯"""
        if len(name) <= 1:
            return name
        return name[0] + '*' * (len(name) - 1)
    
    @staticmethod
    def mask_phone(phone: str) -> str:
        """é›»è©±ç•ªå·ã‚’ãƒã‚¹ã‚¯"""
        if len(phone) <= 4:
            return phone
        return phone[:2] + '*' * (len(phone) - 4) + phone[-2:]
```

### ãƒ‡ãƒ¼ã‚¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—

#### 1. è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
```python
class BackupManager:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, backup_interval: timedelta = timedelta(days=1)):
        self.backup_interval = backup_interval
        self.last_backup = None
    
    def schedule_backup(self):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«"""
        if (self.last_backup is None or 
            datetime.now() - self.last_backup >= self.backup_interval):
            self.perform_backup()
    
    def perform_backup(self):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ"""
        try:
            # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ€ãƒ³ãƒ—
            backup_file = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.sql"
            
            # pg_dumpã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
            subprocess.run([
                'pg_dump',
                '-h', os.getenv('DB_HOST'),
                '-U', os.getenv('DB_USER'),
                '-d', os.getenv('DB_NAME'),
                '-f', backup_file,
                '--no-password'
            ], check=True)
            
            # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æš—å·åŒ–
            self._encrypt_backup_file(backup_file)
            
            # ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            self._upload_to_cloud_storage(backup_file)
            
            self.last_backup = datetime.now()
            logger.info(f"ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†: {backup_file}")
            
        except Exception as e:
            logger.error(f"ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¤±æ•—: {e}")
            raise
```

#### 2. ãƒ‡ãƒ¼ã‚¿å¾©æ—§
```python
class DataRecovery:
    """ãƒ‡ãƒ¼ã‚¿å¾©æ—§ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.backup_manager = BackupManager()
        self.audit_trail = AuditTrail()
    
    def restore_from_backup(self, backup_file: str, target_database: str):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©æ—§"""
        try:
            # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å·åŒ–
            decrypted_file = self._decrypt_backup_file(backup_file)
            
            # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å¾©æ—§
            subprocess.run([
                'psql',
                '-h', os.getenv('DB_HOST'),
                '-U', os.getenv('DB_USER'),
                '-d', target_database,
                '-f', decrypted_file,
                '--no-password'
            ], check=True)
            
            logger.info(f"å¾©æ—§å®Œäº†: {backup_file}")
            
        except Exception as e:
            logger.error(f"å¾©æ—§å¤±æ•—: {e}")
            raise
```

---

## ğŸ”’ é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### HTTPS/TLSè¨­å®š

#### 1. SSL/TLSè¨­å®š
```python
class SecurityHeaders:
    """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š"""
    
    @staticmethod
    def add_security_headers(response):
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ """
        response.headers.update({
            'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': 'DENY',
            'X-XSS-Protection': '1; mode=block',
            'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
            'Referrer-Policy': 'strict-origin-when-cross-origin',
            'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'
        })
        return response
```

#### 2. CORSè¨­å®š
```python
class CORSManager:
    """CORSç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.allowed_origins = [
            'https://your-app.streamlit.app',
            'https://localhost:8501'  # é–‹ç™ºç’°å¢ƒ
        ]
        self.allowed_methods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
        self.allowed_headers = ['Content-Type', 'Authorization']
    
    def add_cors_headers(self, response, origin: str):
        """CORSãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ """
        if origin in self.allowed_origins:
            response.headers.update({
                'Access-Control-Allow-Origin': origin,
                'Access-Control-Allow-Methods': ', '.join(self.allowed_methods),
                'Access-Control-Allow-Headers': ', '.join(self.allowed_headers),
                'Access-Control-Max-Age': '86400'
            })
        return response
```

### APIã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

#### 1. ãƒ¬ãƒ¼ãƒˆåˆ¶é™
```python
class RateLimiter:
    """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.rate_limits = {
            'auth': {'requests': 10, 'window': 60},  # 10å›/åˆ†
            'api': {'requests': 100, 'window': 60},  # 100å›/åˆ†
            'upload': {'requests': 5, 'window': 60}  # 5å›/åˆ†
        }
        self.request_counts = {}
    
    def check_rate_limit(self, client_id: str, endpoint_type: str) -> bool:
        """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’ãƒã‚§ãƒƒã‚¯"""
        current_time = time.time()
        key = f"{client_id}:{endpoint_type}"
        
        # å¤ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‰Šé™¤
        self._cleanup_old_requests(key, current_time)
        
        # ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°ã‚’ãƒã‚§ãƒƒã‚¯
        limit = self.rate_limits[endpoint_type]
        if len(self.request_counts.get(key, [])) >= limit['requests']:
            return False
        
        # æ–°ã—ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¨˜éŒ²
        if key not in self.request_counts:
            self.request_counts[key] = []
        self.request_counts[key].append(current_time)
        
        return True
    
    def _cleanup_old_requests(self, key: str, current_time: float):
        """å¤ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‰Šé™¤"""
        if key in self.request_counts:
            window = self.rate_limits[key.split(':')[1]]['window']
            self.request_counts[key] = [
                req_time for req_time in self.request_counts[key]
                if current_time - req_time < window
            ]
```

#### 2. APIèªè¨¼
```python
class APIAuthentication:
    """APIèªè¨¼ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
    
    def generate_token(self, user_id: str, expires_in: int = 3600) -> str:
        """JWTãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ"""
        payload = {
            'user_id': user_id,
            'exp': datetime.utcnow() + timedelta(seconds=expires_in),
            'iat': datetime.utcnow()
        }
        
        token = jwt.encode(payload, self.secret_key, algorithm='HS256')
        return token
    
    def verify_token(self, token: str) -> Optional[Dict]:
        """JWTãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=['HS256'])
            return payload
        except jwt.ExpiredSignatureError:
            raise AuthenticationError("ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¦ã„ã¾ã™")
        except jwt.InvalidTokenError:
            raise AuthenticationError("ç„¡åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³ã§ã™")
    
    def require_auth(self, func):
        """èªè¨¼è¦æ±‚ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"""
        def wrapper(*args, **kwargs):
            token = self._extract_token_from_request()
            if not token:
                raise AuthenticationError("èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ãŒå¿…è¦ã§ã™")
            
            payload = self.verify_token(token)
            if not payload:
                raise AuthenticationError("èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ")
            
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«è¿½åŠ 
            request.user_id = payload['user_id']
            return func(*args, **kwargs)
        
        return wrapper
```

---

## ğŸ” å…¥åŠ›æ¤œè¨¼

### SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–

#### 1. ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒª
```python
class SafeQueryBuilder:
    """å®‰å…¨ãªã‚¯ã‚¨ãƒªãƒ“ãƒ«ãƒ€ãƒ¼"""
    
    def __init__(self, db_connection):
        self.connection = db_connection
    
    def safe_select(self, table: str, conditions: Dict = None) -> str:
        """å®‰å…¨ãªSELECTã‚¯ã‚¨ãƒªã‚’æ§‹ç¯‰"""
        query = f"SELECT * FROM {table}"
        params = []
        
        if conditions:
            where_clauses = []
            for key, value in conditions.items():
                where_clauses.append(f"{key} = %s")
                params.append(value)
            
            query += " WHERE " + " AND ".join(where_clauses)
        
        return query, params
    
    def safe_insert(self, table: str, data: Dict) -> Tuple[str, List]:
        """å®‰å…¨ãªINSERTã‚¯ã‚¨ãƒªã‚’æ§‹ç¯‰"""
        columns = list(data.keys())
        placeholders = ['%s'] * len(columns)
        
        query = f"INSERT INTO {table} ({', '.join(columns)}) VALUES ({', '.join(placeholders)})"
        params = list(data.values())
        
        return query, params
```

#### 2. å…¥åŠ›ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
```python
class InputSanitizer:
    """å…¥åŠ›ã‚µãƒ‹ã‚¿ã‚¤ã‚¶ãƒ¼"""
    
    @staticmethod
    def sanitize_string(input_str: str, max_length: int = 1000) -> str:
        """æ–‡å­—åˆ—ã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚º"""
        if not input_str:
            return ""
        
        # é•·ã•åˆ¶é™
        if len(input_str) > max_length:
            input_str = input_str[:max_length]
        
        # å±é™ºãªæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        input_str = html.escape(input_str)
        
        # æ”¹è¡Œæ–‡å­—ã‚’æ­£è¦åŒ–
        input_str = input_str.replace('\r\n', '\n').replace('\r', '\n')
        
        return input_str.strip()
    
    @staticmethod
    def validate_email(email: str) -> bool:
        """ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¤œè¨¼"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return bool(re.match(pattern, email))
    
    @staticmethod
    def validate_url(url: str) -> bool:
        """URLã‚’æ¤œè¨¼"""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except:
            return False
    
    @staticmethod
    def sanitize_filename(filename: str) -> str:
        """ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚º"""
        # å±é™ºãªæ–‡å­—ã‚’é™¤å»
        filename = re.sub(r'[<>:"/\\|?*]', '', filename)
        
        # é•·ã•åˆ¶é™
        if len(filename) > 255:
            name, ext = os.path.splitext(filename)
            filename = name[:255-len(ext)] + ext
        
        return filename
```

### XSSå¯¾ç­–

#### 1. å‡ºåŠ›ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
```python
class XSSProtection:
    """XSSå¯¾ç­–ã‚¯ãƒ©ã‚¹"""
    
    @staticmethod
    def escape_html(text: str) -> str:
        """HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—"""
        return html.escape(text)
    
    @staticmethod
    def escape_javascript(text: str) -> str:
        """JavaScriptã‚¨ã‚¹ã‚±ãƒ¼ãƒ—"""
        return json.dumps(text)
    
    @staticmethod
    def escape_sql(text: str) -> str:
        """SQLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—"""
        # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒªã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€ç›´æ¥çš„ãªSQLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã¯é¿ã‘ã‚‹
        return text
    
    @staticmethod
    def validate_content_security_policy(content: str) -> bool:
        """CSPãƒãƒªã‚·ãƒ¼ã«å¾“ã£ãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œè¨¼"""
        # å±é™ºãªã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¿ã‚°ã‚’æ¤œå‡º
        dangerous_patterns = [
            r'<script[^>]*>',
            r'javascript:',
            r'on\w+\s*=',
            r'<iframe[^>]*>'
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return False
        
        return True
```

### ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¤œè¨¼

#### 1. ãƒ•ã‚¡ã‚¤ãƒ«æ¤œè¨¼
```python
class FileUploadValidator:
    """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¤œè¨¼ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.allowed_extensions = {'.txt', '.pdf', '.doc', '.docx'}
        self.max_file_size = 10 * 1024 * 1024  # 10MB
        self.allowed_mime_types = {
            'text/plain',
            'application/pdf',
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        }
    
    def validate_file(self, file) -> Tuple[bool, str]:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œè¨¼"""
        # ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
        if file.size > self.max_file_size:
            return False, "ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™"
        
        # æ‹¡å¼µå­ãƒã‚§ãƒƒã‚¯
        file_extension = os.path.splitext(file.name)[1].lower()
        if file_extension not in self.allowed_extensions:
            return False, "è¨±å¯ã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™"
        
        # MIMEã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯
        if hasattr(file, 'type') and file.type not in self.allowed_mime_types:
            return False, "è¨±å¯ã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™"
        
        # ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®æ¤œè¨¼
        if not self._validate_file_content(file):
            return False, "ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ãŒç„¡åŠ¹ã§ã™"
        
        return True, "ãƒ•ã‚¡ã‚¤ãƒ«ãŒæœ‰åŠ¹ã§ã™"
    
    def _validate_file_content(self, file) -> bool:
        """ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’æ¤œè¨¼"""
        try:
            # ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­éƒ¨åˆ†ã‚’èª­ã¿å–ã‚Š
            file.seek(0)
            header = file.read(1024)
            
            # å±é™ºãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
            dangerous_patterns = [
                b'<?php',
                b'<script',
                b'javascript:',
                b'vbscript:'
            ]
            
            for pattern in dangerous_patterns:
                if pattern in header.lower():
                    return False
            
            return True
            
        except Exception:
            return False
```

---

## ğŸ“Š ç›£æŸ»ãƒ»ãƒ­ã‚°

### ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ­ã‚°

#### 1. ãƒ­ã‚°è¨˜éŒ²
```python
class ActivityLogger:
    """ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ­ã‚°ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.log_levels = {
            'INFO': 1,
            'WARNING': 2,
            'ERROR': 3,
            'CRITICAL': 4
        }
    
    def log_activity(self, user_id: str, activity_type: str, 
                    description: str, metadata: Dict = None):
        """ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’ãƒ­ã‚°ã«è¨˜éŒ²"""
        log_entry = {
            'user_id': user_id,
            'activity_type': activity_type,
            'description': description,
            'metadata': metadata or {},
            'timestamp': datetime.now().isoformat(),
            'ip_address': self._get_client_ip(),
            'user_agent': self._get_user_agent(),
            'session_id': self._get_session_id()
        }
        
        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
        self._save_to_database(log_entry)
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜éŒ²
        self._write_to_security_log(log_entry)
    
    def log_security_event(self, event_type: str, severity: str, 
                          description: str, user_id: str = None):
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ­ã‚°ã«è¨˜éŒ²"""
        security_log = {
            'event_type': event_type,
            'severity': severity,
            'description': description,
            'user_id': user_id,
            'timestamp': datetime.now().isoformat(),
            'ip_address': self._get_client_ip(),
            'user_agent': self._get_user_agent()
        }
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜éŒ²
        self._write_to_security_log(security_log)
        
        # é‡å¤§ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã¯é€šçŸ¥
        if severity in ['HIGH', 'CRITICAL']:
            self._send_security_alert(security_log)
```

#### 2. ãƒ­ã‚°åˆ†æ
```python
class LogAnalyzer:
    """ãƒ­ã‚°åˆ†æã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.suspicious_patterns = [
            'failed_login',
            'sql_injection_attempt',
            'xss_attempt',
            'brute_force_attack'
        ]
    
    def analyze_security_logs(self, time_range: timedelta = timedelta(hours=1)):
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ã‚’åˆ†æ"""
        start_time = datetime.now() - time_range
        
        # ãƒ­ã‚°ã‚’å–å¾—
        logs = self._get_logs_since(start_time)
        
        # ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
        anomalies = self._detect_anomalies(logs)
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
        report = self._generate_security_report(anomalies)
        
        return report
    
    def _detect_anomalies(self, logs: List[Dict]) -> List[Dict]:
        """ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º"""
        anomalies = []
        
        # å¤±æ•—ãƒ­ã‚°ã‚¤ãƒ³ã®é »åº¦ãƒã‚§ãƒƒã‚¯
        failed_logins = [log for log in logs if log['activity_type'] == 'failed_login']
        if len(failed_logins) > 10:  # 1æ™‚é–“ã«10å›ä»¥ä¸Š
            anomalies.append({
                'type': 'brute_force_attempt',
                'count': len(failed_logins),
                'ips': list(set(log['ip_address'] for log in failed_logins))
            })
        
        # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è©¦è¡Œã®æ¤œå‡º
        sql_injection_attempts = [
            log for log in logs 
            if 'sql_injection' in log.get('description', '').lower()
        ]
        if sql_injection_attempts:
            anomalies.append({
                'type': 'sql_injection_attempt',
                'count': len(sql_injection_attempts),
                'ips': list(set(log['ip_address'] for log in sql_injection_attempts))
            })
        
        return anomalies
```

### ç›£æŸ»è¨¼è·¡

#### 1. ãƒ‡ãƒ¼ã‚¿å¤‰æ›´ç›£æŸ»
```python
class AuditTrail:
    """ç›£æŸ»è¨¼è·¡ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.audit_table = 'audit_logs'
    
    def log_data_change(self, user_id: str, table_name: str, 
                       record_id: str, action: str, 
                       old_data: Dict = None, new_data: Dict = None):
        """ãƒ‡ãƒ¼ã‚¿å¤‰æ›´ã‚’ãƒ­ã‚°ã«è¨˜éŒ²"""
        audit_entry = {
            'user_id': user_id,
            'table_name': table_name,
            'record_id': record_id,
            'action': action,  # INSERT, UPDATE, DELETE
            'old_data': json.dumps(old_data) if old_data else None,
            'new_data': json.dumps(new_data) if new_data else None,
            'timestamp': datetime.now().isoformat(),
            'ip_address': self._get_client_ip()
        }
        
        # ç›£æŸ»ãƒ­ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¿å­˜
        self._save_audit_log(audit_entry)
    
    def get_audit_trail(self, table_name: str = None, 
                        record_id: str = None, 
                        user_id: str = None,
                        start_date: datetime = None,
                        end_date: datetime = None) -> List[Dict]:
        """ç›£æŸ»è¨¼è·¡ã‚’å–å¾—"""
        query = f"SELECT * FROM {self.audit_table} WHERE 1=1"
        params = []
        
        if table_name:
            query += " AND table_name = %s"
            params.append(table_name)
        
        if record_id:
            query += " AND record_id = %s"
            params.append(record_id)
        
        if user_id:
            query += " AND user_id = %s"
            params.append(user_id)
        
        if start_date:
            query += " AND timestamp >= %s"
            params.append(start_date.isoformat())
        
        if end_date:
            query += " AND timestamp <= %s"
            params.append(end_date.isoformat())
        
        query += " ORDER BY timestamp DESC"
        
        return self._execute_query(query, params)
```

---

## ğŸš¨ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ

#### 1. ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆæ¤œå‡º
```python
class SecurityIncidentDetector:
    """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆæ¤œå‡ºã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.incident_thresholds = {
            'failed_logins': 5,  # 5åˆ†é–“ã«5å›ä»¥ä¸Šã®å¤±æ•—ãƒ­ã‚°ã‚¤ãƒ³
            'suspicious_ips': 3,  # 3ã¤ã®ç•°ãªã‚‹IPã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹
            'data_access_anomaly': 100  # ç•°å¸¸ã«å¤šã„ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹
        }
    
    def detect_incidents(self) -> List[Dict]:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’æ¤œå‡º"""
        incidents = []
        
        # å¤±æ•—ãƒ­ã‚°ã‚¤ãƒ³ã®æ¤œå‡º
        failed_login_incidents = self._detect_failed_login_incidents()
        incidents.extend(failed_login_incidents)
        
        # ç•°å¸¸ãªãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ã®æ¤œå‡º
        data_access_incidents = self._detect_data_access_incidents()
        incidents.extend(data_access_incidents)
        
        # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è©¦è¡Œã®æ¤œå‡º
        sql_injection_incidents = self._detect_sql_injection_incidents()
        incidents.extend(sql_injection_incidents)
        
        return incidents
    
    def _detect_failed_login_incidents(self) -> List[Dict]:
        """å¤±æ•—ãƒ­ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’æ¤œå‡º"""
        incidents = []
        
        # éå»5åˆ†é–“ã®å¤±æ•—ãƒ­ã‚°ã‚¤ãƒ³ã‚’å–å¾—
        recent_failures = self._get_recent_failed_logins(minutes=5)
        
        # IPã‚¢ãƒ‰ãƒ¬ã‚¹åˆ¥ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        failures_by_ip = {}
        for failure in recent_failures:
            ip = failure['ip_address']
            if ip not in failures_by_ip:
                failures_by_ip[ip] = []
            failures_by_ip[ip].append(failure)
        
        # é–¾å€¤ã‚’è¶…ãˆã‚‹IPã‚’æ¤œå‡º
        for ip, failures in failures_by_ip.items():
            if len(failures) >= self.incident_thresholds['failed_logins']:
                incidents.append({
                    'type': 'brute_force_attack',
                    'severity': 'HIGH',
                    'ip_address': ip,
                    'failure_count': len(failures),
                    'description': f"IP {ip} ã‹ã‚‰ã®ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹æ”»æ’ƒã‚’æ¤œå‡º"
                })
        
        return incidents
```

#### 2. è‡ªå‹•å¯¾å¿œ
```python
class IncidentResponse:
    """ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.response_actions = {
            'brute_force_attack': self._handle_brute_force_attack,
            'sql_injection_attempt': self._handle_sql_injection_attempt,
            'data_access_anomaly': self._handle_data_access_anomaly
        }
    
    def handle_incident(self, incident: Dict):
        """ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’å‡¦ç†"""
        incident_type = incident['type']
        
        if incident_type in self.response_actions:
            self.response_actions[incident_type](incident)
        
        # ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’ãƒ­ã‚°ã«è¨˜éŒ²
        self._log_incident(incident)
        
        # å¿…è¦ã«å¿œã˜ã¦é€šçŸ¥ã‚’é€ä¿¡
        if incident['severity'] in ['HIGH', 'CRITICAL']:
            self._send_incident_notification(incident)
    
    def _handle_brute_force_attack(self, incident: Dict):
        """ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹æ”»æ’ƒã‚’å‡¦ç†"""
        ip_address = incident['ip_address']
        
        # IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä¸€æ™‚çš„ã«ãƒ–ãƒ­ãƒƒã‚¯
        self._block_ip_address(ip_address, duration_minutes=30)
        
        # é–¢é€£ã™ã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒ­ãƒƒã‚¯
        affected_accounts = self._get_accounts_by_ip(ip_address)
        for account in affected_accounts:
            self._lock_account(account['user_id'], duration_minutes=15)
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ã«è¨˜éŒ²
        self._log_security_event(
            'brute_force_blocked',
            'HIGH',
            f"IP {ip_address} ã‚’30åˆ†é–“ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸ"
        )
    
    def _handle_sql_injection_attempt(self, incident: Dict):
        """SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è©¦è¡Œã‚’å‡¦ç†"""
        ip_address = incident['ip_address']
        
        # IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’é•·æ™‚é–“ãƒ–ãƒ­ãƒƒã‚¯
        self._block_ip_address(ip_address, duration_hours=24)
        
        # ç®¡ç†è€…ã«é€šçŸ¥
        self._send_admin_alert(
            'SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è©¦è¡Œ',
            f"IP {ip_address} ã‹ã‚‰ã®SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è©¦è¡Œã‚’æ¤œå‡ºã—ã€24æ™‚é–“ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸ"
        )
```

### å¾©æ—§æ‰‹é †

#### 1. ãƒ‡ãƒ¼ã‚¿å¾©æ—§
```python
class DataRecovery:
    """ãƒ‡ãƒ¼ã‚¿å¾©æ—§ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.backup_manager = BackupManager()
        self.audit_trail = AuditTrail()
    
    def recover_user_data(self, user_id: str, recovery_point: datetime):
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å¾©æ—§"""
        try:
            # å¾©æ—§ãƒã‚¤ãƒ³ãƒˆã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å–å¾—
            backup_data = self.backup_manager.get_backup_at(recovery_point)
            
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å¾©æ—§
            recovered_data = self._restore_user_data(user_id, backup_data)
            
            # å¾©æ—§æ“ä½œã‚’ãƒ­ã‚°ã«è¨˜éŒ²
            self.audit_trail.log_data_change(
                user_id='system',
                table_name='users',
                record_id=user_id,
                action='RECOVERY',
                new_data={'recovery_point': recovery_point.isoformat()}
            )
            
            return recovered_data
            
        except Exception as e:
            logger.error(f"ãƒ‡ãƒ¼ã‚¿å¾©æ—§å¤±æ•—: {e}")
            raise
    
    def rollback_changes(self, table_name: str, record_id: str, 
                        rollback_point: datetime):
        """å¤‰æ›´ã‚’ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯"""
        try:
            # ç›£æŸ»è¨¼è·¡ã‹ã‚‰å¤‰æ›´å±¥æ­´ã‚’å–å¾—
            changes = self.audit_trail.get_audit_trail(
                table_name=table_name,
                record_id=record_id,
                start_date=rollback_point
            )
            
            # å¤‰æ›´ã‚’é€†é †ã«é©ç”¨
            for change in reversed(changes):
                if change['action'] == 'UPDATE':
                    self._apply_rollback(change)
                elif change['action'] == 'DELETE':
                    self._restore_deleted_record(change)
                elif change['action'] == 'INSERT':
                    self._delete_inserted_record(change)
            
            logger.info(f"ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Œäº†: {table_name}.{record_id}")
            
        except Exception as e:
            logger.error(f"ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤±æ•—: {e}")
            raise
```

---

## ğŸ“‹ ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹

### å€‹äººæƒ…å ±ä¿è­·

#### 1. ãƒ‡ãƒ¼ã‚¿æœ€å°åŒ–
```python
class DataMinimization:
    """ãƒ‡ãƒ¼ã‚¿æœ€å°åŒ–ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.required_fields = {
            'users': ['user_id', 'email', 'display_name'],
            'practice_sessions': ['session_id', 'user_id', 'practice_type_id', 'start_time']
        }
    
    def minimize_data_collection(self, data: Dict, table_name: str) -> Dict:
        """ãƒ‡ãƒ¼ã‚¿åé›†ã‚’æœ€å°åŒ–"""
        required = self.required_fields.get(table_name, [])
        minimized_data = {}
        
        for field in required:
            if field in data:
                minimized_data[field] = data[field]
        
        return minimized_data
    
    def anonymize_user_data(self, user_id: str):
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’åŒ¿ååŒ–"""
        # å€‹äººè­˜åˆ¥æƒ…å ±ã‚’å‰Šé™¤
        self._remove_personal_data(user_id)
        
        # çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã¯ä¿æŒï¼ˆåŒ¿ååŒ–ï¼‰
        self._anonymize_statistics(user_id)
        
        # åŒ¿ååŒ–æ“ä½œã‚’ãƒ­ã‚°ã«è¨˜éŒ²
        self._log_anonymization(user_id)
```

#### 2. ãƒ‡ãƒ¼ã‚¿ä¿æŒæœŸé–“
```python
class DataRetention:
    """ãƒ‡ãƒ¼ã‚¿ä¿æŒæœŸé–“ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.retention_policies = {
            'practice_sessions': timedelta(days=365),  # 1å¹´
            'practice_inputs': timedelta(days=365),
            'practice_scores': timedelta(days=365),
            'audit_logs': timedelta(days=2555),  # 7å¹´
            'security_logs': timedelta(days=2555)
        }
    
    def cleanup_expired_data(self):
        """æœŸé™åˆ‡ã‚Œãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤"""
        current_time = datetime.now()
        
        for table_name, retention_period in self.retention_policies.items():
            cutoff_date = current_time - retention_period
            
            # æœŸé™åˆ‡ã‚Œãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
            deleted_count = self._delete_expired_data(table_name, cutoff_date)
            
            if deleted_count > 0:
                logger.info(f"{table_name}: {deleted_count}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ")
    
    def _delete_expired_data(self, table_name: str, cutoff_date: datetime) -> int:
        """æœŸé™åˆ‡ã‚Œãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤"""
        query = f"""
        DELETE FROM {table_name} 
        WHERE created_at < %s
        """
        
        result = self._execute_query(query, [cutoff_date.isoformat()])
        return result.rowcount
```

### ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

#### 1. æ¨©é™ç®¡ç†
```python
class AccessControl:
    """ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.permission_matrix = {
            'user': {
                'read_own_data': True,
                'write_own_data': True,
                'read_others_data': False,
                'admin_functions': False
            },
            'admin': {
                'read_own_data': True,
                'write_own_data': True,
                'read_others_data': True,
                'admin_functions': True
            }
        }
    
    def check_permission(self, user_id: str, permission: str) -> bool:
        """æ¨©é™ã‚’ãƒã‚§ãƒƒã‚¯"""
        user_role = self._get_user_role(user_id)
        if not user_role:
            return False
        
        return self.permission_matrix.get(user_role, {}).get(permission, False)
    
    def enforce_data_access_control(self, user_id: str, target_user_id: str) -> bool:
        """ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã‚’å¼·åˆ¶"""
        # è‡ªåˆ†ã®ãƒ‡ãƒ¼ã‚¿ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
        if user_id == target_user_id:
            return True
        
        # ç®¡ç†è€…æ¨©é™ãƒã‚§ãƒƒã‚¯
        if self.check_permission(user_id, 'read_others_data'):
            return True
        
        return False
```

---

*ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ç¶™ç¶šçš„ã«æ›´æ–°ã•ã‚Œã¾ã™ã€‚æœ€æ–°ç‰ˆã¯GitHubãƒªãƒã‚¸ãƒˆãƒªã§ç¢ºèªã—ã¦ãã ã•ã„ã€‚* 